from kramer.courses.Course import Course
from dbclients.clients.mongodb import get_mongodb_client

# Connect to the MongoDB database - sync
syncClient = get_mongodb_client("sync")
syncdb = syncClient.kramer


# Define a function that inserts a Course object into the MongoDB database
async def insert_course_into_mongodb(course: Course):
    """
    TODO: add upsert logic, since we have a unique index on course_admin_id
    # Example mongoshell command:
    db.courses.replaceOne(
    { course_admin_id: 2818049 },  // filter criteria
    newDocumentObject,             // your new document
    { upsert: true }               // tells MongoDB to update if exists, insert if doesn't
    )
    # Python equivalent using motor:
    await collection.replace_one(
    { "course_admin_id": 2818049 },
    """
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses

    await asyncCourses.replace_one(
        {"course_admin_id": course.course_admin_id},  # filter criteria
        course.model_dump(),  # new document
        upsert=True,  # insert if doesn't exist, update if does
    )


def insert_course_into_mongodb_sync(course: Course):
    """
    TODO: add upsert logic, since we have a unique index on course_admin_id
    # Example mongoshell command:
    db.courses.replaceOne(
    { course_admin_id: 2818049 },  // filter criteria
    newDocumentObject,             // your new document
    { upsert: true }               // tells MongoDB to update if exists, insert if doesn't
    )
    # Python equivalent using pymongo:
    collection.replace_one(
    { "course_admin_id": 2818049 },
    """
    return syncdb.courses.replace_one(
        {"course_admin_id": course.course_admin_id},  # filter criteria
        course.model_dump(),  # new document
        upsert=True,  # insert if doesn't exist, update if does
    )


# Delete functions
async def delete_course_by_id(id: int):
    """
    Deletes a course from the MongoDB database by its course_admin_id.
    """
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    result = await asyncCourses.delete_one({"course_admin_id": id})
    if result.deleted_count == 1:
        print(f"Deleted course with course_admin_id {id} from the MongoDB database.")
    else:
        print(f"Course with course_admin_id {id} not found in the MongoDB database.")


def delete_course_by_id_sync(id: int):
    """
    Deletes a course from the MongoDB database by its course_admin_id.
    """
    result = syncdb.courses.delete_one({"course_admin_id": id})
    if result.deleted_count == 1:
        print(f"Deleted course with course_admin_id {id} from the MongoDB database.")
    else:
        print(f"Course with course_admin_id {id} not found in the MongoDB database.")


# Ensure consistency between this courses table and the course_mapping table.
def upsert_titles(course_dict: dict) -> None:
    """
    Upserts the course titles in the MongoDB database.
    Used for consistency between the courses table and the course_mapping table; run this with process_cosmo.py.

    Args:
    course_dict (dict): A dictionary where the keys are course_admin_ids and the values are course titles.
    """
    for course_admin_id, title in course_dict.items():
        # Check if the course exists in the database
        course = syncdb.courses.find_one({"course_admin_id": course_admin_id})
        if course:
            # Update the title if it exists
            syncdb.courses.update_one(
                {"course_admin_id": course_admin_id},
                {
                    "$set": {
                        "metadata.Course Name EN": title,
                        "metadata.Course Name": title,
                        "course_title": title,
                    },
                },
            )


# Define a function that retrieves all Course objects from the MongoDB database
async def get_all_courses():
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    courses = await asyncCourses.find().to_list(length=None)
    return set([Course(**course) for course in courses])


def get_all_courses_sync():
    courses = syncdb.courses.find()
    return [Course(**course) for course in courses]


async def get_all_licensed_courses():
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    courses = await asyncCourses.find(
        {
            "metadata.Contract Type": {"$regex": "LICENSED"},
            "metadata.Activation Status": "ACTIVE",
        }
    ).to_list(length=None)
    return set([Course(**course) for course in courses])


def get_all_licensed_courses_sync():
    courses = syncdb.courses.find(
        {
            "metadata.Contract Type": {"$regex": "LICENSED"},
            "metadata.Activation Status": "ACTIVE",
        }
    )
    return [Course(**course) for course in courses]


# Define a function that gets the last course from the MongoDB database by chronological order with the _id field
async def get_latest_course():
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    course = await asyncCourses.find_one(sort=[("_id", -1)])
    return Course(**course)


def get_latest_course_sync():
    course = syncdb.courses.find_one(sort=[("_id", -1)])
    return Course(**course)


# Define a function that returns a set of all the course_admin ids forasyncCourses in the MongoDB database
async def get_all_course_ids_from_mongodb():
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    course_ids = set(await asyncCourses.distinct("course_admin_id"))
    return course_ids


def get_all_course_ids_from_mongodb_sync():
    return set(syncdb.courses.distinct("course_admin_id"))


# Define a function that gets instructor names from the MongoDB database
async def get_instructor_names_from_mongodb():
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    instructor_names = set(await asyncCourses.distinct("metadata.Instructor Name"))
    return instructor_names


def get_instructor_names_from_mongodb_sync():
    return set(syncdb.courses.distinct("metadata.Instructor Name"))


# Define a function that retrieves a random Course object from the MongoDB database
async def get_random_course():
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    cursor = asyncCourses.aggregate([{"$sample": {"size": 1}}])
    course = await cursor.next()
    return Course(**course)


def get_random_course_sync():
    cursor = syncdb.courses.aggregate([{"$sample": {"size": 1}}])
    course = cursor.next()
    return Course(**course)


# Define a function that retrieves a Course object by its course_admin_id from the MongoDB database
async def get_course_by_id_from_mongodb(course_admin_id: int):
    # Connect to the MongoDB database - async
    asyncClient = await get_mongodb_client("async")
    asyncdb = asyncClient.kramer
    asyncCourses = asyncdb.courses
    course = await asyncCourses.find_one({"course_admin_id": course_admin_id})
    return Course(**course)


def get_course_by_id_from_mongodb_sync(course_id: int):
    course = syncdb.courses.find_one({"course_admin_id": course_id})
    if course is not None:
        return Course(**course)


# Define a function that deletes the last n records from the MongoDB database, according to the _id field. Synchronous.
def delete_last_n_records(n: int):
    """
    Deletes the last n records from the MongoDB database, according to the _id field, which is a timestamp.
    """
    courses = syncdb.courses.find().sort("_id", -1).limit(n)
    for course in courses:
        syncdb.courses.delete_one({"_id": course["_id"]})
    print(f"Deleted {n} records from the MongoDB database.")


# We have LOTS of tables -- make sure that course_mapping is the Master
def ensure_mapping_consistency():
    """
    Ensure every course in main collection has a mapping.
    Run this to fix any existing consistency issues.
    """
    from kramer.database.MongoDB_course_mapping import (
        get_course_ids,
        load_single_course_manually,
    )

    # Get IDs from both collections
    all_course_ids = get_all_course_ids_from_mongodb_sync()
    mapping_ids = set(get_course_ids())

    # Find courses without mappings
    missing_mappings = all_course_ids - mapping_ids

    if not missing_mappings:
        print("âœ… All courses have mappings - database is consistent")
        return True

    print(f"Found {len(missing_mappings)} courses without mappings:")

    for course_id in missing_mappings:
        try:
            course = get_course_by_id_from_mongodb_sync(course_id)
            if course:
                load_single_course_manually(course_id, course.course_title)
                print(f"âœ… Added missing mapping: {course_id} -> {course.course_title}")
        except Exception as e:
            print(f"âŒ Failed to add mapping for {course_id}: {e}")

    print("Database consistency check complete.")
    return len(missing_mappings) == 0


# Validate it
def validate_database_consistency():
    """
    Check for consistency issues between collections.
    Returns True if consistent, False if issues found.
    """
    from kramer.database.MongoDB_course_mapping import get_course_ids

    course_ids = set(get_all_course_ids_from_mongodb_sync())
    mapping_ids = set(get_course_ids())

    orphaned_courses = course_ids - mapping_ids  # Courses without mappings
    missing_courses = mapping_ids - course_ids  # Mappings without courses

    if orphaned_courses:
        print(f"âš ï¸  Courses without mappings: {len(orphaned_courses)} courses")
        print(f"   First few: {list(orphaned_courses)[:5]}")

    if missing_courses:
        print(f"âš ï¸  Mappings without courses: {len(missing_courses)} mappings")
        print(f"   First few: {list(missing_courses)[:5]}")

    is_consistent = len(orphaned_courses) == 0 and len(missing_courses) == 0

    if is_consistent:
        print("âœ… Database is consistent")
    else:
        print("âŒ Database has consistency issues")
        print("ğŸ’¡ Run ensure_mapping_consistency() to fix")

    return is_consistent


if __name__ == "__main__":
    licensed_courses = get_all_licensed_courses_sync()
