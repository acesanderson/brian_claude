# /// script
# dependencies = [
#   "jinja2",
# ]
# ///

import asyncio
import sys
import json
import os
import shutil
from datetime import datetime
from jinja2 import Template

# --- CONFIGURATION ---
MAX_CONCURRENT_WORKERS = 5
TIMEOUT_SECONDS = 120  # 2 minutes per task hard limit
BATCH_DIR_NAME = "batch_runs"


async def run_worker(sem, run_id, index, item, skill_name, user_template):
    """
    Spawns a single isolated Claude Code instance.
    """
    async with sem:
        # 1. Setup Isolation
        # We create a folder, but we DO NOT change the CWD of the subprocess.
        # This ensures Claude still sees .claude/config.toml and project-level skills.
        task_dir = os.path.abspath(
            os.path.join(BATCH_DIR_NAME, run_id, f"task_{index}")
        )
        os.makedirs(task_dir, exist_ok=True)

        output_file = os.path.join(task_dir, "result.json")

        # 2. Render Prompt
        # We inject strict instructions about where to write.
        system_instructions = (
            f"SYSTEM OVERRIDE: You are a headless worker agent. "
            f"You are restricted to working strictly within this directory: {task_dir}. "
            f"You have permission to use the '{skill_name}' tool. "
            f"Do not ask for confirmation. Do not output conversational filler. "
            f"Perform the task and save the final structured data to: {output_file}."
        )

        try:
            # Jinja2 rendering for the user's specific task
            t = Template(user_template)
            task_prompt = t.render(item=item, task_id=index, output_file=output_file)
        except Exception as e:
            return {
                "status": "error",
                "item": item,
                "error": f"Template Error: {str(e)}",
            }

        full_prompt = (
            f"{system_instructions}\n\nTASK INPUT: {item}\nINSTRUCTIONS: {task_prompt}"
        )

        # 3. Construct Command
        # -p: Print mode (non-interactive)
        # --dangerously-skip-permissions: The "Yes to all" flag
        cmd = ["claude", "-p", full_prompt, "--dangerously-skip-permissions"]

        print(f"[{index}] Starting task for: {item} ...")

        try:
            # 4. Execute
            process = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )

            # Wait with timeout
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=TIMEOUT_SECONDS
            )

            # 5. Harvest Results
            if process.returncode == 0:
                # Check if the output file actually exists
                if os.path.exists(output_file):
                    try:
                        with open(output_file, "r") as f:
                            data = json.load(f)
                        print(f"[{index}] Success.")
                        return {"status": "success", "item": item, "data": data}
                    except json.JSONDecodeError:
                        print(f"[{index}] Failed: Output was not valid JSON.")
                        return {
                            "status": "error",
                            "item": item,
                            "error": "Invalid JSON in output file",
                        }
                else:
                    print(f"[{index}] Failed: No output file found.")
                    return {
                        "status": "error",
                        "item": item,
                        "error": "Output file missing",
                        "logs": stdout.decode(),
                    }
            else:
                print(f"[{index}] Crushed (Exit Code {process.returncode}).")
                return {"status": "error", "item": item, "error": stderr.decode()}

        except asyncio.TimeoutError:
            print(f"[{index}] Timed out. Killing.")
            try:
                process.kill()
            except:
                pass
            return {"status": "timeout", "item": item}


async def main():
    if len(sys.argv) < 4:
        print("Usage: batch_runner.py <skill> <json_inputs> <template>")
        sys.exit(1)

    skill_name = sys.argv[1]
    raw_inputs = sys.argv[2]
    template = sys.argv[3]

    try:
        # Handle cases where the CLI might pass inputs as a python string representation
        # or a strict JSON string.
        inputs = json.loads(raw_inputs)
    except json.JSONDecodeError:
        print("Error: Inputs must be a valid JSON array string.")
        sys.exit(1)

    run_id = datetime.now().strftime("%Y%m%d_%H%M%S")
    run_dir = os.path.join(BATCH_DIR_NAME, run_id)
    os.makedirs(run_dir, exist_ok=True)

    print(f"--- Batch Dispatch Initiated ---")
    print(f"Run ID: {run_id}")
    print(f"Items: {len(inputs)}")
    print(f"Skill: {skill_name}")

    sem = asyncio.Semaphore(MAX_CONCURRENT_WORKERS)

    tasks = [
        run_worker(sem, run_id, i, item, skill_name, template)
        for i, item in enumerate(inputs)
    ]

    # Run all
    results = await asyncio.gather(*tasks)

    # Aggregate
    summary_path = os.path.join(run_dir, "_summary.json")
    with open(summary_path, "w") as f:
        json.dump(results, f, indent=2)

    # Output only the summary path to stdout so the Main Claude sees it cleanly
    print(f"\nBatch Job Complete.")
    print(f"Summary saved to: {summary_path}")


if __name__ == "__main__":
    asyncio.run(main())
